# -*- coding: utf-8 -*-
"""BinaryTrees.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/12Evjk29vi79_Sl9xiBYzSEkM46hFQewm

# Binary Trees
"""
from dlist import DList
import queue #it is Python module to implement queues

class Node:
  
  def __init__(self,elem=None):
    self.elem=elem
    self.leftChild=None
    self.rightChild=None
    self.parent=None
    
    
class BinaryTree:
  def makelist(self):
      mylis = DList()
      self._makelist(self.root, mylis)
      return mylis
     
  def _makelist(self, node, mylis):      
      if node!= None:
          self._makelist(node.leftChild, mylis)
          mylis.addLast(node.elem)
          self._makelist(node.rightChild,mylis)
          
  def __init__(self):
    self.root=None
    
  def sizeOf(self, parameter):
      "return the size of a particular given node"
      return self._size(parameter)
    
  def size(self):
    """Returns the number of nodes"""
    return self._size(self.root)
      
  def _size(self,currentNode):
    if currentNode==None:
      return 0
    
    return 1 + self._size(currentNode.leftChild) + self._size(currentNode.rightChild)
   
    
  def height(self):
    """Returns the height of the tree"""
    return self._height(self.root)
  
  def _height(self,currentNode):
    if currentNode==None:
      return -1
    
    return 1 + max(self._height(currentNode.leftChild), self._height(currentNode.rightChild))

  def depth(self,currentNode):
    """Returns the depth of a node"""
  
    if currentNode==None:
      return -1
    
    return 1 + self.depth(currentNode.parent)

  
  def preorder(self):
    print('pre-order traversal')  
    self._preorder(self.root)
    print()
    
  def _preorder(self,currentNode):
    if currentNode!=None:
      print(currentNode.elem,end=' ')
      self._preorder(currentNode.leftChild)
      self._preorder(currentNode.rightChild)  
      
  def postorder(self):
    print('post-order traversal')  
    self._postorder(self.root)
    print()
    
  def _postorder(self,currentNode):
    if currentNode!=None:
      self._postorder(currentNode.leftChild)
      self._postorder(currentNode.rightChild)
      print(currentNode.elem,end=' ')
      
      
      
  def inorder(self):
    # print('in-order traversal')  
    self._inorder(self.root)
    print()
    
  def _inorder(self,currentNode):
    if currentNode!=None:
      self._inorder(currentNode.leftChild)
      print(currentNode.elem)
      self._inorder(currentNode.rightChild)
      
      

  def draw(self):
      """Fucntion to draw a tree"""
      self._draw('',self.root,False)
      print()
      
  def _draw(self,prefix, node, isLeft):
    if node !=None:
        self._draw(prefix + "     ", node.rightChild, False)
        print(prefix + ("|-- ") + str(node.elem))
        self._draw(prefix + "     ", node.leftChild, True)
    

    
  def levelorder(self):
    if self.root==None:
      print('tree is empty')
      return
    print('level-order traversal')
    q=queue.Queue()
    q.put(self.root) #we save the root
    
    while q.empty()==False:
      current=q.get() #dequeue
      print(current.elem, end=' ')
      if current.leftChild:
        q.put(current.leftChild)
      if current.rightChild:
        q.put(current.rightChild)
    
    print()


